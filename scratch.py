#! /usr/bin/env python

#Copyright (c) 2014, Vertical Research Group, University of Wisconsin-Madison
#Copyright (c) 2017  IT - Coimbra, Universidade de Coimbra and INESC-ID,
#Universidade de Lisboa
#
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#
#1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#2. Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#3. Neither the name of the copyright holder nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#4. The use of this tool in research works and publications, assumes that
#   the following articles are cited:
#
#SCRATCH Framework (MIAOW 2.0):
# - P. Duarte, P. TomÃ¡s, G. Falcao. SCRATCH: A Soft-GPU Architecture and
#   Trimming Tool for Application-Specific Contexts. In IEEE/ACM
#   International Symposium on Microarchitecture (MICRO), Oct. 2017, pp 1-12.
#
#Original MIAOW:
# - Balasubramanian R, Gangadhar V, Guo Z, Ho CH, Joseph C, Menon J, Drumond MP,
#   Paul R, Prasad S, Valathol P, Sankaralingam K. Enabling gpgpu low-level
#   hardware explorations with miaow: An Open-Source RTL Implementation of a GPGPU.
#   ACM Transactions on Architecture and Code Optimization (TACO), Jul. 2015,
#   vol. 12, no. 2, pp. 21.
#   
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import csv, os, argparse, pprint
import app_proc

class scratch():
    def __init__(self,csv_file,MIAOW_folder):
        self.csv_file     = csv_file
        self.miaow_folder = MIAOW_folder
        self.folder       = os.path.dirname(os.path.realpath(__file__))
        self.app          = app_proc.app_proc(self.csv_file)
        self.type_list    = []
        self.req_inst     = {}
        self.valus        = ['simd','simf']
        self.used_fus     = [] 
        self.fu_opcodes   = {}

    def trim_arch(self):
        # Obtains the necessary instructions, hardware functional units and
        #instruction types from the provided CSV
        # Initializes:
        # - the required instruction dictionary
        # - the used functional units list
        # - the required types list
        # - Calls all the trimming functions (one function performs the trimming of a single file)
        self.req_inst,self.type_list = self.app.get_instructions()

        self.used_fus   = [k.lower() for k in self.req_inst.keys()]
        self.fu_opcodes = self._format_opcodes()

        self._proc_decode_core()
        self._proc_compute_unit()
        self._proc_simd_alu()
        self._proc_salu()
        self._proc_simf()
        #decode units in valus?
        #flag_generator

    def _print_log(self,log):
        # Orders the log generated by a given function and prints it
        if log == []: return
        plog = list(set(log))
        plog.sort()
        print "\n\r".join(plog)

    def _format_opcodes(self):
        # Processes the required instructions dictionary to obtain all opcodes for a given format
        # Outputs a nested structure hardware_FU -> formats used -> opcodes used
        fu_opcodes = {}
        for fu in self.req_inst:
            opcodes = {}
            for inst in self.req_inst[fu]:
                op  = int(inst[2],2)
                fmt = inst[1]
                
                if fmt not in opcodes:
                    opcodes[fmt] = [op]
                else:
                    opcodes[fmt].append(op)
            fu_opcodes[fu] = opcodes
        return fu_opcodes

    def _conditional_append(self,tlines, line, jump):
       #Performs an append only if the jump flag is not set
       if not jump:
           tlines.append(line)

    def _proc_decode_core(self):
        # Trims the decode core by removing any logic that is unnecessary for the given application
        with open(os.path.join(self.miaow_folder,"decode_core.v"),'r') as f:
            lines = f.readlines()

        tlines = []
        log    = []

        inside_main_block  = False
        entered_main_block = False
        jump               = False
        level              = 0
        cur_level          = 0

        for line in lines:
            ns_line = line.strip()

            if not inside_main_block:
                # While we are not in the main always block we don't need to trim
                # Append line and check if we have reached the main always block
                ns_line = ns_line.split("@")
                if ns_line[0].strip() == "always" and "collated_instr" in ns_line[1]:
                    entered_main_block = True
                    inside_main_block  = True
                tlines.append(line)

            elif entered_main_block:
                #if the begining of the main block was just detected wait until "begin" occurs
                tlines.append(line)
                if "begin" in ns_line:
                    entered_main_block = False
                    level += 1

            else:
                #Process main block
                ns_line = ns_line.split()

                if len(ns_line) == 0:
                    #Ignore empty lines
                    self._conditional_append(tlines, line, jump)
                    continue

                op = ns_line[0]

                if len(op) < 2:
                    self._conditional_append(tlines, line, jump)
                    continue

                elif op[:2] == "//":
                   #ignore comments
                   self._conditional_append(tlines, line, jump)

                elif op[:4] == "32'b":
                    #Process opcode entry
                    # - Obtain opcode for the case entry, replace all '?' with zeros
                    # - Obtain the corresponding type
                    # - Check if type is required (exists in type list)
                    # - If yes, continue without jumping
                    # - If no , set the jump flag to ignore this entry
                    fmt    = "".join(op[4:-1].split('_')).replace('?','0')
                    i_type = self.app.get_instruction_type(inst_b=fmt)

                    if i_type in self.type_list:
                        #should be kept
                        tlines.append(line)
                        jump = False
                    else:
                        #remove
                        jump      = True
                        cur_level = level

                elif op == "end":
                    #if an end is detected decrease the level
                    # if the level corresponds to the one where we started jumping over, stop jumping
                    # if we reach level 0 we have exited the main block
                    self._conditional_append(tlines, line, jump)
                    level -= 1

                    if level == 0:
                        inside_main_block = False

                    elif level == cur_level:
                        cur_level = 0
                        jump      = False

                elif op == "begin":
                    #increase the level at every begin
                    self._conditional_append(tlines, line, jump)
                    level += 1

                else:
                    self._conditional_append(tlines, line, jump)

        #Write trimmed file
        with open(os.path.join(self.folder,"decode_core.v"),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

    def _proc_compute_unit(self):
        # Processes the top level file compute_unit.v responsible for
        #instantiating the functional units
        cu_file_name = "compute_unit.v"
        cu_file      = os.path.join(self.miaow_folder,cu_file_name)

        if not os.path.isfile(cu_file):
          cu_file_name = "compute_unit_fpga.v"
          cu_file      = os.path.join(self.miaow_folder,cu_file_name)
          assert os.path.isfile(cu_file)

        with open(cu_file,'r') as f:
            lines = f.readlines()

        tlines   = []
        log      = []
        jump     = False
        fu_count = {}
        
        for line in lines:
            nline = line.split()
            nline = [l.strip() for l in nline]
            self._conditional_append(tlines, line, jump)

            #Skip empty lines
            if len(nline) < 1:
                continue
            elif nline[0] in self.valus:
                #If current line performs the instantiation of a valu:
                # - Check if it is used:
                    # - If not used: jump over
                    # - Keep counter of removed fu's for better debugging
                valu = nline[0]
                if valu not in self.used_fus:
                    if valu not in fu_count:
                        fu_count[valu] = 0
                    else:
                        fu_count[valu] = fu_count[valu] + 1

                    log.append("Removing FU: {}{}".format(valu,fu_count[valu]))
                    tlines.pop()
                    jump = True
            else:
                #Process until the end of the instantiation
                nline = "".join(nline)
                if ');' in nline:
                    jump = False

        #Write trimmed file
        with open(os.path.join(self.folder,cu_file_name),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

    def _proc_simd_alu(self):
        # Process simd unit to remove support for unused instructions
        if "simd" not in self.used_fus: return

        #This processing assumes 5 "always" blocks where the 4th one is the multiplication inputs one and the last one is the multiplication cycle control block

        with open(os.path.join(self.miaow_folder,"simd_alu.v"),'r') as f:
            lines = f.readlines()
        
        simd_insts  = self.req_inst["SIMD"]
        simd_fmts   = [inst[1] for inst in simd_insts]
        simd_fmts   = list(set(simd_fmts))
        opcodes     = self.fu_opcodes["SIMD"]
        tlines      = []
        log         = []
        in_block    = False
        in_case     = False
        jump        = False
        mul_delete  = False
        mul_jump    = False
        num_cases   = 0
        level       = 0
        cur_level   = 0
        block_level = 0
        case_level  = 0
        count_block = 0
        count_mul   = 1

        # Check if a multiplication occurs if not mark it for deletion
        mul_insts   = [i[0] for i in simd_insts if i[0].startswith("V_MUL")]

        if len(mul_insts) == 0:
            mul_delete = True

        for line in lines:
            nline = line.split()
            nline = [l.strip() for l in nline]
            nline = [l         for l in nline if l != ""]
            self._conditional_append(tlines, line, jump)
            
            # Skip empty lines
            if len(nline) < 1:
                continue

            if not jump:
                # If not marked for jump process lines:
                # Count always blocks
                # Blocks 4 and 5 control multiplication and are removed if no multiplication occurs
                # If not in a block remove multiplication assignment (if no multiplication occurs)
                # If in a case: check for every option (instruction) if it should be kept or removed. If removed jump goes high
                if nline[0][:6] == "always":
                    in_block     = True
                    block_level  = level
                    count_block += 1
    
                    if   count_block == 5 and mul_delete:
                        log.append("Deleting multiplication cycle control block")
                        tlines.pop()
                        jump      = True
                        cur_level = level
                        level    += 1 # artificial level increment because block has no "begin" statement
                        count_mul = 1
    
                    elif count_block == 4 and mul_delete:
                        log.append("Deleting multiplication input control block")
                        tlines.pop()
                        jump      = True
                        cur_level = level
                        count_mul = 0
                        mul_jump  = True
    
                elif not in_block:
                    # assign res = a * b
                    if mul_delete:
                        if len(nline) > 1:
                            if nline[0] == "assign":
                                op = "".join(nline[1:])
                                op = op.split('=')[1]
                                op = op.split('*')
        
                                if len(op) == 2: # Multiplication, if none in insts remove
                                    tlines.pop()
    
                elif in_case:
                    opt = "".join(nline)
                    if opt.startswith("{1'b1,`ALU_"):
                        opts = opt.split(',')
                        fmt  = opts[1].split('_')[1]

                        if fmt not in simd_fmts:
                            log.append("Deleting format: {0:5} from SIMD".format(fmt))
                            tlines.pop()
                            cur_level = level
                            jump      = True

                        else:
                            if len(opts) < 2:
                                continue
    
                            op       = opts[2].split("'")
                            bitwidth = int(op[0]) if op[0].isdigit() else 32
                            op_type  = op[1][0]
                            base     = 10

                            if op_type   == 'h':
                                base = 16
                            elif op_type == 'b':
                                base = 2
    
                            op_val = op[1][1:].split('}')
                            op_val = op_val[0].strip()
                            op_val = int(op_val,base)

                            if op_val not in opcodes[fmt]:
                                log.append("Deleting opcode: {0:5} from {1:5} in SIMD".format(op_val,fmt))
                                tlines.pop()
                                cur_level = level
                                jump      = True

            # Increase level at every begin and case_level at every level
            if "begin" in nline or nline[0][:4] == "case":
                level += 1
                if nline[0][:4] == "case":
                    case_level  += 1
                    in_case      = True

            if in_block and count_mul == 1 and count_block == 5 and "else" in nline:
                #decrease artificial level introduced in 5th block (multiplier with no "begin", "end")
                count_mul  = 0
                level     -= 1
            # Decrease level at every end and case_level at every end_case
            if "end" in nline or "endcase" in nline:
                level -= 1

                if "endcase" in nline:
                    case_level -= 1
                    if case_level == 0:
                        in_case = False

                if level == cur_level:
                    jump  = False

                if level == block_level:
                    in_block    = False
                    block_level = 0

        #Write trimmed file
        with open(os.path.join(self.folder,"simd_alu.v"),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

    def _proc_simf(self):
        #SIMF process includes two files "simf_alu" and "fpu_arith"
        if "simf" not in self.used_fus: return
        self._proc_simf_alu()
        self._proc_fpu_arith()

    def _proc_simf_alu(self):
        #Process main file of FP-VALU
        if "simf" not in self.used_fus: return

        with open(os.path.join(self.miaow_folder,"simf_alu.v"),'r') as f:
            lines = f.readlines()
        
        simf_insts  = self.req_inst["SIMF"]
        simf_fmts   = [inst[1] for inst in simf_insts]
        simf_fmts   = list(set(simf_fmts))
        opcodes     = self.fu_opcodes["SIMF"]
        tlines      = []
        in_block    = False
        in_case     = False
        in_comment  = False
        jump        = False
        num_cases   = 0
        level       = 0
        cur_level   = 0
        block_level = 0
        case_level  = 0
        count_block = 0
        log         = []

        for line in lines:
            nline = line.split()
            nline = [l.strip() for l in nline]
            nline = [l         for l in nline if l != ""]
            self._conditional_append(tlines, line, jump)
            
            # Ignore empty lines
            if len(nline) < 1:
                continue

            #Jump over comments
            if in_comment:
                if "*/" in "".join(nline):
                    in_comment = False
                continue

            if not jump:
                #If jump is not set process line:
                # - Check if a block was entered or
                # - If a multi-line comment was started
                # - If in a case process the options according to the list of required instructions

                if nline[0][:6] == "always":
                    in_block     = True
                    block_level  = level
                    count_block += 1

                elif "/*" in "".join(nline):
                    in_comment = True

                elif in_case:
                    opt = "".join(nline)
                    if opt.startswith("{1'b1,`ALU_"):
                        opts = opt.split(',')
                        fmt  = opts[1].split('_')[1]
                        if fmt not in simf_fmts:
                            log.append("Deleting format: {0:5} from SIMF".format(fmt))
                            tlines.pop()
                            cur_level = level
                            jump      = True
                        else:
                            if len(opts) < 2:
                                continue

                            op       = opts[2].split("'")
                            bitwidth = int(op[0]) if op[0].isdigit() else 32
                            op_type  = op[1][0]
                            base     = 10
                            if op_type == 'h':
                                base = 16
                            elif op_type == 'b':
                                base = 2

                            op_val = op[1][1:].split('}')
                            op_val = op_val[0].strip()
                            op_val   = int(op_val,base)
                            if op_val not in opcodes[fmt]:
                                log.append("Deleting opcode: {0:5} from {1:5} in SIMF".format(op_val,fmt))
                                tlines.pop()
                                cur_level = level
                                jump      = True

            # If case or begin is found increase the corresponding level
            if "begin" in nline or nline[0][:4] == "case":
                level += 1
                if nline[0][:4] == "case":
                    case_level  += 1
                    in_case      = True

            
            # if end or endcase is found decrease level
            if "end" in nline or "endcase" in nline:
                level -= 1

                if "endcase" in nline:
                    case_level -= 1
                    if case_level == 0:
                        in_case = False

                if level == cur_level:
                    jump  = False

                if level == block_level:
                    in_block    = False
                    block_level = 0

        #Write trimmed file
        with open(os.path.join(self.folder,"simf_alu.v"),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

    def _proc_fpu_arith(self):
        #Process file responsible for instantiating floating point arithmetic unit
        # These can be:
        #  - Conversions between float and integer/unsigned
        #  - Multiplications
        #  - Addition
        #  - Subtraction
        #  - Division

        with open(os.path.join(self.miaow_folder,"fpu_arith.v"),'r') as f:
            lines = f.readlines()

        tlines     = []
        jump       = False
        simf_insts = self.req_inst["SIMF"]
        simf_insts = [inst[0] for inst in simf_insts]
        operations = [i.split('_')[1] for i in simf_insts]
        units      = []
        log        = []

        if "CVT" in operations:
            units.append("conv")
        if "RCP" in operations:
            units.append("div")
        if "ADD" in operations:
            units.append("addsub")
        for op in operations:
            if   op.startswith("SUB") and "addsub" not in units:
                  units.append("addsub")
            elif op.startswith("M"):
                if "mul" not in units:
                    units.append("mul")
                if op[1] == "A" and "addsub" not in units: #mac, mad, ...
                    units.append("addsub")

        for line in lines:
            nline = line.split()
            nline = [l.strip() for l in nline]
            nline = [l         for l in nline if l!=""]
            self._conditional_append(tlines, line, jump)
            
            #Ignore empty lines
            if len(nline) < 1:
                continue

            #Identify lines with unit instantiations
            # If no instruction requires this unit then remove it
            if len(nline) > 1 and nline[0].startswith("fpu_") and nline[1].startswith("fpu_"):
                operation = nline[0].split("_").pop()
                if operation not in units:
                    tlines.pop()
                    jump = True
                    log.append("Removing SIMF's sub-unit: {}".format(nline[0]))
            else:
                nline = "".join(nline)
                if ');' in nline:
                    jump = False

        #Write trimmed file
        with open(os.path.join(self.folder,"fpu_arith.v"),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

    def _proc_salu(self):
        #Processing of scalar alu
        with open(os.path.join(self.miaow_folder,"scalar_alu.v"),'r') as f:
            lines = f.readlines()

        salu_insts  = self.req_inst["SALU"]
        salu_fmts   = [inst[1] for inst in salu_insts]
        salu_fmts   = list(set(salu_fmts))
        opcodes     = self.fu_opcodes["SALU"]

        tlines      = []
        log         = []
        in_block    = False
        in_type     = False
        in_case     = False
        jump        = False
        level       = 0
        block_level = 0
        type_level  = 0
        case_level  = 0
        cur_level   = 0
        type_nm     = ""

        for line in lines:
            nline = line.split()
            nline = [l.strip() for l in nline]
            nline = [l         for l in nline if l!=""]
            jline = "".join(nline)
            self._conditional_append(tlines, line, jump)
            
            #Ignore empty lines
            if len(nline) < 1:
                continue

            if not jump:

                #Identify the beggining of always blocks
                if nline[0][:6] == "always":
                    in_block    = True
                    block_level = level
                
                #Identify the beggining of a case block
                elif in_block and nline[0][:4] == "case" and not in_case:
                    in_case    = True
                    case_level = level

                #If inisde a case block process each entry
                #If it is a type that is not used then remove
                #If it is an instruction (inside a type that does exist) that is not used then remove
                elif in_case:
                    if not in_type:
                        if nline[0][:8] == "{`SALU_S":
                            in_type    = True
                            type_level = level
                            salu_fmt   = nline[0].split('_')[1]
                            type_nm    = salu_fmt

                            if salu_fmt not in salu_fmts:
                                log.append("Deleting format: {0:5} from SALU".format(salu_fmt))
                                tlines.pop()
                                jump      = True
                                cur_level = level
                    else:
                        opc = nline[0].split("'")

                        if len(opc) > 1:
                           #Process opcode
                           if (opc[0].isdigit() or (opc[0]=="" and opc[1][1:].isdigit())):
                               base   = opc[1][0 ]
                               opcode = opc[1][1:]

                               if   base == "h":
                                    base = 16
                               elif base == "b":
                                    base =  2
                               else :
                                    base = 10

                               opcode = int(opcode,base)

                               if opcode not in opcodes[type_nm]:
                                  log.append("Deleting opcode: {0:5} from {1:5} in SALU".format(opcode,type_nm))
                                  tlines.pop()
                                  jump      = True
                                  cur_level = level
                    
            # If case or begin is found increase the level
            if "begin" in nline or nline[0][:4] == "case":
                level += 1

            # If an end is found decrease the level
            if "end" in nline or "endcase" in nline:
                level -= 1

                if level == cur_level:
                    jump     = False

                if level == block_level:
                    in_block = False

                if level == case_level:
                    in_case  = False

                if level == type_level:
                    in_type  = False

        #Write trimmed file
        with open(os.path.join(self.folder,"scalar_alu.v"),'w') as f:
            f.writelines(tlines)

        self._print_log(log)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Trim MIAOW core to specific application. Requires a csv file generated by CodeXL upon kernel compilation and the location of the original MIAOW FPGA core.")
    parser.add_argument('--instruction_csv', '-f', default=None)
    parser.add_argument('--MIAOW_folder'   , '-m', default="fpga_core")
    args = parser.parse_args()
    assert (args.instruction_csv is not None), "Please provide a csv file"

    framework = scratch(args.instruction_csv,args.MIAOW_folder)
    framework.trim_arch()
